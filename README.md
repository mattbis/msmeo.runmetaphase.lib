# msmeo.runmetaphase.lib

### swift reasoning without reading the previous public source...  testing my memory

.. most of the extremely crazy arch i was thinking about; teh reason I like it is reducing the amount of code that deals with this.. into abstracts that are powerful... ( albeit somewhat obtuse to use at first ) ( yet are a lambda essentially )

they are almost like hooks.. since they allow somebody to modify it with a modicum of knowledge and hook into the various things... most are like preprocessors.. 

intended for configuration when metadata is concerned; the main reason i want this is when you start dealing with other languages and tooling its a big bull of mud of stuff... you can doit pretty eloquently but i cant help but get annoyed at duplicating anything, rather id define a logic model and then this generates everything.. it does exist, but here you can use your fav language instead... or a mixture... ( one reason why id do it )... often this stuff is core to everything... so it also should be how ai is controlled etc// like an extended config file...  with schema stuff.. etc

defs stack, run until destroyed, called often, selectors have to be explicit and enabled.. but very powerful.. 

i like making extremely configurable things... so you could entirely redefine parts of the tool logic easily... a standard for configuration to this power with meta programming would eb really useful since you could code around a lot of things that are not possible in a static file.. perhaps... and well have some kind of structure 

only allows static definitions, everything is a definition or setting something prior .. as a machine, so its easily deconstructed..  with code that can reference the phase it runs in
